/*! \mainpage Introduction
 * 
 * This is a simple user's and developer's manual for OSHUN. 
 * 
 * OSHUN is a fully parallel Vlasov-Fokker-Planck-Maxwell code [1,2] that relies on an arbitrary-order
 * Spherical Harmonic expansion of the distribution function in 3D momentum space.
 * This enables modeling of significant anisotropies in the distribution function
 * e.g. those in two-stream instabilities. The expansion is truncated such that the necessary angular
 * resolution of the distribution function is retained for a given problem. Finite collisionality 
 * causes rapid decay of the high-order harmonics, thereby providing a natural truncation mechanism for the expansion.
 * 
 * The fields and configuration space are defined over a 1D or 2D Cartesian grid. (There are minor differences
 * in the way the 1D and 2D code work so they're left as separate entities.). The Vlasov equation is treated in a
 * fully relativistic fashion. 
 *   
 * The Fokker-Planck operator is non-relativistic and linearized. The effect of electron-electron collisions on the isotropic component of the
 * distribution can be calculated explicitly or implicitly while electron-ion and electron-electron collisions are treated implicitly for 
 * the anisotropic components of the distribution function.
 * 
 * The code has both fully explicit and implicit field-solvers and assumes an infinitely massive and cold ion background.
 *
 * OSHUN has been benchmarked against recovering transport coefficients in magnetized plasmas.
 * 
 * The normalizations are provided in \ref norm "here". 
 * 
 * The way OSHUN determines the time loop from the inputdeck parameters is listed \ref timing "here".
 *  
 * References:
 * 
 * [1] - Tzoufras, M., Bell, A. R., Norreys, P. A., & Tsung, F. S. (2011). A Vlasov-Fokker-Planck code for high energy density physics. Journal of Computational Physics, 230(17), 6475â€“6494. <a href="http://dx.doi.org/10.1016/j.jcp.2011.04.034">10.1016/j.jcp.2011.04.034</a>
 *
 * [2] - Tzoufras, M., Tableman, A., Tsung, F. S., Mori, W. B., & Bell, A. R. (2013). A multi-dimensional Vlasov-Fokker-Planck code for arbitrarily anisotropic high-energy-density plasmas. Physics of Plasmas, 20(5), 056303. <a href="http://dx.doi.org/10.1063/1.4801750">10.1063/1.4801750</a>
 * 
 * Since the manual is generated by Doxygen, it also contains technical information
 * about the code. 
 * 
 * Acknowledgements:
 * - C++ Mathematical Expression Toolkit Library by Arash Partow - http://www.partow.net/programming/exprtk/index.html  
 */
 


 /*! \page norm Normalizations
 * The equation set used in OSHUN is normalized such that the mass is
 * normalized to the electron mass, the velocity to the speed of light 
 * and the time to the inverse of the electron plasma frequency. 
 * 
 * For a collisionless problem, the units are specified by setting the
 * normalizing density.
 * 
 * For a collisional problem, Z0 also needs to be provided as 'hydrocharge' 
 * in the input deck.
 * 
 * 
 * The full list is as follows:
 * 
  * \f$ \tilde{n} = n / n_0 = n / n_{input} \f$
  * 
  * \f$ \tilde{Z} = Z / Z0 \f$
  * 
 * \f$\tilde{t} = t / t_n = t \times \omega_{p0} = t \times \sqrt{n_0 e^2 / m \epsilon_0}\f$
 *  
 * \f$\tilde{v} = v / c \f$ 
  * 
  * \f$\tilde{x} = x / \lambda_n = x / (c / \omega_p)  \f$
 * 
 * 
 * \f$\tilde{T} = T / T_n = T / m_e c^2\f$
 * 
 */
 
/*! \page timing Time loop setup
 * The relevant parameters in the input deck are 
 * 
 * \f$ t_{stop} \f$, \f$ n_{outsteps} \f$, \f$ clf_{dp} \f$. These correspond to the simulation end time in normalized units,
 * the number of desired outputs, and the maximum time-step
 * 
 * \f$ t_{stop} / n_{outsteps} \f$ has to be an integer. If that is satisfied, the code enters a loop that goes from the 1st output step to the last.
 * Within this loop, the goal is to have another loop such that OSHUN runs from beginning to end with a maximum time-step given
 * by \f$ clf_{dp} \f$. 
 * 
 * Numerically, it can be described by the following.
 * 
 * The first loop is given by
 * 
 * \code for (size_t t_{out}(tout_start + 1); t_{out} < n_{outsteps} + 1; ++t_{out}) \endcode
 * 
 * where tout_start = 0. Therefore, the loop goes from output no. 1 to output no. \f$n_{outsteps}\f$. Within this loop, the following
 * is performed
 * 
 * \code for (Clock W(t_{out} - 1, dt_{out}, CLF); W.tick() < W.numh(); ++W) \endcode
 * 
 * where \f$dt_{out} = t_{stop} / n_{outsteps}\f$. 
 * 
 * The Clock function is responsible for determining the time step. First, it calculates the number of timesteps within each clock loop using 
 * \f$ numh = (dt_{out} / clf_{dp}) + 1\f$ to ensure that \f$clf_{dp} > timestep\f$. Using \f$numh\f$, the timestep is determined by
 * \f$ h = dt_{out} / numh \f$.
 * 
 * This same Clock loop is performed \f$n_{outsteps}\f$ times.
 * 
 * 
 */
 